# 创建

通道的结构体表示
```go
type hchan struct {
	qcount   uint           // 缓冲槽有效数据数量
	dataqsiz uint           // 缓冲槽大小
	buf      unsafe.Pointer // 缓冲槽指针
	elemsize uint16         // 数据项大小
	closed   uint32         // 是否关闭
	elemtype *_type         // 数据项类型
	sendx    uint           // 缓冲槽发送位置索引
	recvx    uint           // 缓冲槽接收位置索引
	recvq    waitq          // 接收者等待队列
	sendq    waitq          // 发送者等待队列

	lock mutex
}
```
`sudog`表示等待中的G  
```go
type waitq struct {
	first *sudog
	last  *sudog
}
```
创建通道
```go
func makechan(t *chantype, size int) *hchan {
```

# 收发
必须对 channel 收发双方(G)进行包装，因为要携带数据项，存储相关状态。  

channel还需要维护发送和接收队列，以及异步缓冲槽环状队列索引位置

## 同步

同步模式的关键是找到匹配的接收或发送方，找到则直接拷贝数据，找不到就将自身打包 后放入等待队列，由另一方复制数据并唤醒

在同步模式下，channel 的作用仅是维护发送和接收者队列，数据复制与 channel 无关。 另外在唤醒后，需要验证唤醒者身份，以此决定是否有实际的数据传递

**Send**

`src/runtime/chan.go:140:func chansend`  
1. 加锁 `181:lock(&c.lock)`
2. 获取一个接收者  `188:sg := c.recvq.dequeue()`
   如果获取到了则发送数据 然后将`hchan`的sendx++
3. 比较缓冲槽与缓冲槽的有效数据量 如果相等则是一个有缓冲的channel 
   然后获取缓冲槽的第hchan.sendx个槽的指针qp
   `typedmemmove`从发送者复制数据
   然后使hchan.sendx++ hchan.qcount++ 解锁后返回
4. 如果`block`为`false` 说明不阻塞当前g 此时会直接返回 false
5. 如果`block`为`true`
   这个G的状态会被设置为waiting 移除与线程M的关系，然后被打包为sudog，
   并且放入`hchan.sendq`中 sudog结构保存了channel相关变量的指针
6. 当接受者g2可以接收数据了，会通知调度器，设置发送者g1的状态为runningable，然后将加入P的runqueue中，等待执行