# micro.Newservice
```go
service := micro.NewService(
	micro.Name("srv_name"),
	micro.Version("latest"),
	micro.RegisterTTL(time.Second*30),
	micro.RegisterInterval(time.Second*15),
	micro.Registry(registry.Etcd(cfg.EtcdConfig.Endpoints...)),
	)
```
`micro.NewService`创建服务，实际是返回一个一个实现`micro.Service`接口的struct `service`
```go
type service struct {
	opts Options

	once sync.Once
}
```
然后`newOptions`创建将传入的参数初始化返回`micro.Options`这个结构体,然后将返回初始化好的配置置入`micro.service`中然后再返回，这时创建新服务已经完成。
micro实现了可以默认配置参数的一种方法

创建服务中传入的配置全是返回这种格式的配置
```go
type Option func(*Options)
```


**以在创建服务时指定服务名称为例**
`micro.Name("crocodile.srv.actuator")`会返回一个`Option`的函数
然后进入`Name`中查看实际返回的是
```
// Name of the service
func Name(n string) Option {
	return func(o *Options) {
		o.Server.Init(server.Name(n))
	}
}
```
这种函数的格式刚好符合`micro.Option`的格式，并且返回的函数需要传入一个`Options`的结构体,
参数n就是传入的服务名称，然后进入`service.Name`函数，
```
func Name(n string) Option {
	return func(o *Options) {
		o.Name = n
	}
}
```
在此函数Name又返回一个`micro.Option`的的函数，在这个函数`o.Name = n`可以看到将`Options.Name`修改为了传入的服务名称，但是在这里只是返回了这个修改的函数，但是还未修改，

真正执行这些配置函数是通过`options := newOptions(opts...)`这句才将所有的参数初始化完成的
```go
opt := Options{
	Broker:    broker.DefaultBroker,
	Cmd:       cmd.DefaultCmd,
	Client:    client.DefaultClient,
	Server:    server.DefaultServer,
	Registry:  registry.DefaultRegistry,
	Transport: transport.DefaultTransport,
	Context:   context.Background(),
}
for _, o := range opts {
	o(&opt)
}
```
`opt`是一个Options结构体，并且全部都有默认值，`o`为修改配置的函数，上面看到所有修改配置都是一个可以传入`Options指针`参数的函数，在这个函数内将`Options`的值才修改完成的，所有这个循环结束后，配置的参数也就生效了，在micro中随处可以很多这样修改配置的函数，既可以默认参数，又可以修改默认的参数，很方便

然后返回修改后的结构体返回，然后下面就到了
然后构造service


# srv.Init
它的工作主要是再次渲染传入Init的Option配置项，然后再初始化命令行参数。

```go
func (s *service) Init(opts ...Option) {
    // process options
    // 生效传入的配置
	for _, o := range opts {
		o(&s.opts)
	}
    // 生效命令行传入的配置
	s.once.Do(func() {
		// Initialise the command flags, overriding new service
		_ = s.opts.Cmd.Init(
			cmd.Broker(&s.opts.Broker),
			cmd.Registry(&s.opts.Registry),
			cmd.Transport(&s.opts.Transport),
			cmd.Client(&s.opts.Client),
			cmd.Server(&s.opts.Server),
		)
	})
}
```
所以在micro中配置生效的的顺序为  
`随构造函数传入的参数` < `Init函数传入的函数` < `Cmd传入的参数`

# registry
# run