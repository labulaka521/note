# 并发控制
## 读写锁
在处理并发读或者写时，可以通过实现一个有两类型的锁组成的锁系统来解决问题。这两种类型的锁通常被成为共享锁(shared lock) 排他锁(exclusive lovk),也叫做读写和写锁

读锁是共享的，相互不阻塞的。  
写锁是排他的，也就是说一个写锁会阻塞其他的写锁和读锁。
## 锁粒度  
让锁定对象更有选择性  
只锁定需要修改的部分数据。
- 表锁(table lock) InnoDB MyISAM
- 行级锁(row lock) InnoDB

# 事务  
- 原子性 atomicity
- 一致性 consistency
- 隔离型 isolation
- 持久性 durability

## 隔离级别  
较低的隔离通常可以执行更高的并发  
系统的开销也低   

- READ UNCOMMITED 未提交读  
事务的修改，即使没有提交，对其他事务也都是可见的。事务可以读取未提交的数据，这也被成为脏读。这个级别会导致很多问题  

- READ COMMITED 提交读  
大部分数据库系统的默认隔离级别都是READ COMMITED（mysql不是）。一个事务从开始知道提交之前，所做的任何修改对其他事务都是不可见的。  
- PEPEATABLE READ 可重复读  
解决了脏读的问题。保证了在同一个事务中多次读取同样的记录是一致的。但是无法解决幻读。所谓幻读就是在读取某个范围的记录时，另一个事务在此范围又插入了新的记录。
- SERIALIZABLE 可串行化  
最高的隔离级别。它通过强制事务串行执行，避免了前面说的幻读。

## 死锁  
死锁是指两个或者多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。
当多个事务试图以不同的顺序锁定资源时，就可能产生死锁。多个事务同时锁定同一个资源时，也会产生死锁。
数据库的解决办法  
- InnoDB存储引擎可以检测到死锁的循环依赖，并返回一个错误。  
- 查询的时间达到锁等待超时的设定后放弃锁请求。

锁的行为和顺序是和存储引擎相关的。

# MySQL中的事务  
## 自动提交 autocommit  
mysql默认采用自动提交的模式。  
`SHOW VARIABLES LIKE 'AUTOCOMMIT'`  
mysql通过执行`SET TRANSACTION ISOLATION LEVEL READ COMMITED`来设置隔离级别  
## 隐式和显示锁定  
InnoDB采用的是两阶段锁定协议。在事务执行的过程中，随时都可以执行锁定，锁只有在执行COMMIT或者ROLLBACK的时候才会释放，并且所有的锁都是在同一时刻被释放。


# Mysql的存储引擎  
Mysql将每个数据库保存为数据目录下的一个子目录，每一个表创建数据库子目录下一个和表同名的`.frm`文件保存表的定义。  
使用`SHOW TABLE STATUS LIKE 'table_name'`来查看表的相关信息  
```

MariaDB [nams_db]> show table status like 'nams_extranetip'\G;
*************************** 1. row ***************************
           Name: nams_extranetip
         Engine: InnoDB
        Version: 10
     Row_format: Compact
           Rows: 4237
 Avg_row_length: 375
    Data_length: 1589248
Max_data_length: 0
   Index_length: 0
      Data_free: 10485760
 Auto_increment: 5092
    Create_time: 2018-09-18 15:32:37
    Update_time: NULL
     Check_time: NULL
      Collation: utf8_general_ci
       Checksum: NULL
 Create_options:
        Comment:
1 row in set (0.00 sec)
```
## MySQL存储引擎  

#### InnoDB存储引擎
InnoDB的数据存储在表空间(tablespace)中。 可以将每个表的数据和索引放在单独的文件中。    
InnoDB采用MVCC(多版本并发控制)来支持高并发，并且实现了四个标准的隔离级别。默认为`REPEATABLE READ`。并且通过间隙锁策略防止幻读的出现。
>MVCC (Multiversion Concurrency Control)，即多版本并发控制技术,它使得大部分支持行锁的事务引擎，不再单纯的使用行锁来进行数据库的并发控制，取而代之的是把数据库的行锁与行的多个版本结合起来，只需要很小的开销,就可以实现非锁定读，从而大大提高数据库系统的并发性能


InnoDB是基于聚簇索引建立的。对逐渐查询有很高的性能。
#### MyISAM 存储引擎  
MyISAM不支持事务和行级锁。  
不支持奔溃后的安全恢复。  
对于只读的数据，使用MyISAM比较好  
MyISAM将表存储在两个文件：数据文件和索引文件MYD MYI 为扩展名。  
**MySIAM特性**  
- 加锁和并发  
对整张表加锁，而不是针对行  
读取时会对整张表加锁，而不是针对行。读取时会对需要读的所有表加共享锁，写入时对表加排他锁。
- 修复  
Mysql可以手动或者自动执行检查和修复操作 
- 索引特性  
支持全文索引
- 延迟更新索引键  
创建MyISAM表的时候，如果指定了`DELAY_KEY_WRITE`选项，每次修改执行完，不会立即将修改的索引数据写入磁盘，而是写入内存中的键缓冲区，只有在清理缓冲区或者表关闭时才将对应的索引块写入磁盘。

**MyISAM压缩表**  
可以使用myisampack对MyISAM表进行压缩。不能修改，减少IO，压缩表也支持索引，但是只读的。

# 基准测试  
- 吞吐量  
吞吐量指的是单位时间内的事务处理数
- 响应时间或者延迟  
测试任务所需的整体时间  
- 并发性  


# 数据类型  

- 优化数据类型  
尽量使用可以正确存储数据的最小数据类型  
尽量避免使用NULL  这使得索引，索引统计和值比较都比较复杂。NULL的列会使用更多的存储空间，在MySQL里也需要特殊处理。如果计划在列上使用索引，就应该尽量避免设计成可为NULL的列
### 整类型  
有两种类型的数字
- 整数
`TINYINT`8，`SMALLINT`16，`MEDIUMINT`24，`INT`36，`BIGINT`64  存储范围-2^(n-2)~2^(n-2)-1  
可以设置`UNSIGNED`，表示不允许复制，可以将正数提高一倍
- 实数  
`FLOAT` `DOUBLE` `DECIMAL`
- 字符串类型   
    - VARCHAR  
    类型用来存储可变长字符  
    使用1或2个额外的字节记录字符串的长度，如果列的最大长度小于或等于255字节，则使用1个字节表示，否则使用两个字节  
    **使用场景：**
    字符串最大长度比平均长度大很多；列的更新很少  
    - CHAR  
    类型是定长的，当尾部有空格时mysql会删除，采用空格填充。  
    适合存储很短的字符串，或者所有值都接近同一个长度，有效率
    对于经常变更的数据，CHAR也比VARCHAR好，不容易产生碎片。

- 日期和时间类型  
    - DATETIME  
    可以保存大范围的值，从1001年到9999年，精度为秒。  YYYYMMDDHHMMSS的整数中。使用8个字节。 
    - TIMESTAMP  
    保存了从1970年1月1日到现在的秒数  
    只需要4个字节的存储空间  
    FORM_UNIXTIME()将时间戳转换为日期  
    UNIX_TIMESTAMP()把日期转换为时间戳
    
- 特殊类型  
    存储IP 
    实际上是32位无符号整型。  
    mysql提供了`INET_ATON()`和`INET_NOTA()`函数来转换IP与32位无符号整型    
    所以可以使用int来表示IP  
    插入数据时可以使用`INET_ATON('ip')`来将IP转换为数字  
    读取数据时可以使用`INET_NOTA('num')`来将整型数据转换为IP  
    ```
    MariaDB [test]> select inet_aton('192.168.0.1');
    +--------------------------+
    | inet_aton('192.168.0.1') |
    +--------------------------+
    |               3232235521 |
    +--------------------------+
    1 row in set (0.00 sec)
    
    MariaDB [test]> select inet_ntoa('3232235521')
        -> ;
    +-------------------------+
    | inet_ntoa('3232235521') |
    +-------------------------+
    | 192.168.0.1             |
    +-------------------------+
    1 row in set (0.00 sec)
    ```
  
# 索引  
### 索引类型
- B-Tree索引  
B- tree索引适用于全键值，键值范围或键前缀查找
其中前缀查找只适用于根据最左前缀的查找。  
    - B-tree索引的限制。  
        如果不是按照索引的最左列开始查找，则无法使用索引。  
        不能跳过索引中的列  
        如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化。  

- 哈希索引  
哈希索引基于哈希表实现，只有精确匹配索引所有列的查询才有效  
对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码(hash code)，哈希索引将哈希码存储在索引中，同时在哈希中保存指向每一个数据的指针。   
**限制**  
    - “哈希索引只包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读取行。不过，访问内存中的行的速度很快，所以大部分情况下这一点对性能的影响并不明显。  
    - 哈希索引数据并不是按照索引值顺序存储的，所以也就无法用于排序。  
    - 哈希索引也不支持部分索引列匹配查找，因为哈希索引始终是使用索引列的全部内容来计算哈希值的。例如，在数据列（A,B）上建立哈希索引，如果查询只有数据列A，则无法使用该索引。
    - 哈希索引只支持等值比较查询，包括=、IN()、<=>（注意<>和<=>是不同的操作）。也不支持任何范围查询，例如WHERE price>100。
    - 访问哈希索引的数据非常快，除非有很多哈希冲突（不同的索引列值却有相同的哈希值）。当出现哈希冲突的时候，存储引擎必须遍历链表中所有的行指针，逐行进行[…]”


###  索引优点  
>索引可以让服务器快速的定位到表的指定位置  
>由于B-Tree索引是按照顺序存储的，所以mysql可以用来做`ORDER_BY`和`GROUP_BY`操作。

优点:
- 索引大大减少了服务器扫描的数据量
- 索引可以帮助服务器避免排序和临时表
- 索引可以将随机IO变为顺序IO
