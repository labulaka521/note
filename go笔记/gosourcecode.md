# 内存分配

基本策略
- 每次从操作系统申请一大块内存，以减少系统调用
- 将申请到的大块内存按照特定大小预先切分成小块，构成链表
- 为对象分配内存时，只需从大小合适的链表提取一个小块即可
- 回收对象内存时，将改小块内存重新归还到原链表，以便复用
- 如闲置内存过多，则尝试归还部分内存给操作系统，降低整体开销

**初始化**

因为内存分配器和垃圾回收算法都依赖连续地址，所以在初始化阶段,会预先保留了很大的一段虚拟地址内存。

>保留内存地址，但是不分配内存


分为三个区域


---
|spans|bitmap|arena|
-|-|-


- 使用arena地址像操作系统申请内存，其大小决定了可分用用户内存上限
- 位图bitmap为每个对象提供4bit标记位，用以保存指针，GC等标记信息
- 创建span时，按页填充对应spans空间。在回收object时，只需将其地址按页对象后就可找到所属 span。分配器还用此访问相邻 span，做合并操作。


**初始化工作**
1. 创建对象规格大小对照表。
2. 计算相关区域大小，并尝试从某个指定位置开始保留地址空间。
3. 在 heap 里保存区域信息，包括起始位置和大小。
4. 初始化 heap 其他属性。

# 垃圾回收

三色标记和写屏障

• 起初所有对象都是白色。  
• 扫描找出所有可达对象，标记为灰色，放入待处理队列。    
• 从队列提取灰色对象，将其引用对象标记为灰色放入队列，自身标记为黑色。 • 写屏障监视对象内存修改，重新标色或放回队列。

当完成全部扫描和标记工作后，剩余不是白色就是黑色，分别代表要待回收和活跃对象， 清理操作只需将白色对象内存收回即可

# 并发调度

[基本关系示意图](https://www.dropbox.com/s/7ac617gd2zm2na0/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202019-03-26%2019.34.02.png?dl=0)

G-P-M

P(Processor)，用来控制可同时并发执行的任务数量。每个工作线程都必须绑定一个有效P才被允许执行任务，否则只可以休眠，直到有空闲P时被唤醒。P还未线程提供执行资源，比如对象分配，本地队列等。

进程内的一切都以goroutine方式运行，包括运行时相关服务，以及main.main入口函数。
G仅仅保存并发任务状态，为任务执行提供所需要的内存空间。G任务创建后被放置在P本地队列或者全剧队列，等待工作线程调度执行。

实际执行体为系统线程(M)，和P绑定，以调度循环方式不停执行G并发任务。M通过修改寄存器，将执行栈指向G自带栈内存，并在此空间分配堆栈帧，执行任务函数。当需要中途切换时，只要将相关寄存器值保存回G空间即可维持状态，任何M可据此恢复执行。线程仅负责执行，不再持有状态，这就是并发任务线程调度，实现多路复用的根本所在。
